--Author: Yu-Yang Lin

I have implemented both Recursive Descent and Predictive Parsers.
To test them, run the Interpreter module:

    ghci Interpreter.hs
    :set +s -- to output time/space taken for a function

The interpreter module can access functions required to test Predictive and Recursive Descent Parsing.
------------------------------------------------------------------------------------------------------
To evaluate the result:

    runR <Input String>  -- To use Recursive Descent to parse <Input String>
    runP <Input String>  -- To use Predictive Recursive Descent to parse <Input String>

    -- Both functions evaluate the result if possible.
    -- If a variable is involed, they cannot evaluate and will throw an error.
    -- Evaluation is based on Integer class, which does not have an upper limit, unlike Int.
    -- Thus, you can have expressions as big as memory will allow.
------------------------------------------------------------------------------------------------------
To try the Lexical Analysis Function:

    lexicalAnalysis :: String -> [Token]
    lexicalAnalysis <Input String>  -- Where <Input String> is the desired string to tokenise.
------------------------------------------------------------------------------------------------------
To see the tree built by the parsers:

    parseR <Input String>  -- Recursive Descent parser prase tree in Abstract Syntax
    parseP <Input String>  -- Predictive parse tree in Abstract Syntax
    parsePC <Input String> -- Predictive parse tree in Concrete Syntax
                           -- I like how Abstract and Concrete have the same word length, they line up.
------------------------------------------------------------------------------------------------------
To test the parsers without a huge string output:

    testP <Input String>  -- To run parseP without printing the tree
    testR <Input String>  -- To run parseR without printing the tree
    testPC <Input String> -- To run parsePC without printing the tree

    -- These are useful to check the complexity of each parser (given :set +s)
------------------------------------------------------------------------------------------------------
To test how the parsers respond to huge data, I wrote the following functions:

    createSum, createMul, createBrackets :: Int -> Int -> String
    createSum a n       -- creates a String of n a's added together. ie: a1 + a2 + ... + aN, a1 = a2 = aN
    createMul a n       -- creates a String of n a's multiplied together. ie: a1 * a2 * ... * aN, a1 = a2 = aN
    createBrackets a n  -- creates a String of 'a' nested in n brackets.  ( ... ( a ) ... )

    createString :: String -> Int -> String
    createString s n    -- creates a String of 's' repeated n-times

======================================================================================================
------------------------------------------------------------------------------------------------------
======================================================================================================

A FEW COMMENTS:

    I like the Recursive Descent Parser implementation more than the Predictive one.
    This because it uses a more concise grammar and its implementation is easier to read.
    This is also because the predictive parser implementation looks ugly when compared
    to the recursive one, in my opinion.

    Initially, I thought the Predictive Parser would be faster than the Recursive one.
    However, from my test data (shown in the next section), the Recursive parser proved to have
    lower time and space complexity than the Predictive one. Rate of growth with regards to input
    size favoured the Recursive Parser every time.

    From this, either my implementation is really slow (which is very possible), the parser I
    thought was Rercursive Descent is actually a form of predictive parser, or the grammar is
    too simple to really see predictive parsing in action.

    My conclusion was that my recursive parser dealt with 4 production rules, and wasn't too
    complicated, while the predictive parser effectively required dealing with 9 rules. This
    increase in the complexity of the grammar used might mean that for this simple grammar,
    Recursive Descent is faster than Predictive Parser.


    Another possibility is that Haskell's lazy evaluation causes funny things to occur.
    It wouldn't be the first time lazy evaluation has intrigued me with its results.

    eg.
        --calculates a^n by building an infinite list, taking n items, and multiplying them together.
        power :: Num a => a -> Int -> a
        power a n = foldr (*) 1 (take n (cycle [a]))

        From an exercise, I discovered this is faster and uses less space than defining a
        tail-recursive function.
        I don't know why, but I guess its due to how Haskell evaluates recursion.

======================================================================================================
------------------------------------------------------------------------------------------------------
======================================================================================================

EXAMPLE TEST DATA:

EVALUATING BRACKETs:
    *Interpreter> runR (createBrackets 5 100)
    5
    (0.00 secs, 518740 bytes)
    *Interpreter> runR (createBrackets 5 1000)
    5
    (0.02 secs, 2392792 bytes)
    *Interpreter> runR (createBrackets 5 10000)
    5
    (0.34 secs, 21874872 bytes)
    *Interpreter> runR (createBrackets 5 100000)
    5
    (1.70 secs, 215702408 bytes)
    *Interpreter> runR (createBrackets 5 1000000)
    5
    (16.50 secs, 2151789880 bytes)

    *Interpreter> runP (createBrackets 5 100)
    5
    (0.00 secs, 1067976 bytes)
    *Interpreter> runP (createBrackets 5 1000)
    5
    (0.03 secs, 4880016 bytes)
    *Interpreter> runP (createBrackets 5 10000)
    5
    (0.30 secs, 41014024 bytes)
    *Interpreter> runP (createBrackets 5 100000)
    5
    (3.03 secs, 406879544 bytes)
    *Interpreter> runP (createBrackets 5 1000000)
    5
    (31.25 secs, 4066047060 bytes)

EVALUATING ADDITION:
    *Interpreter> runR (createSum 2 100)
    200
    (0.00 secs, 1067664 bytes)
    *Interpreter> runR (createSum 2 1000)
    2000
    (0.03 secs, 6252920 bytes)
    *Interpreter> runR (createSum 2 10000)
    20000
    (0.25 secs, 60095060 bytes)
    *Interpreter> runR (createSum 2 100000)
    200000
    (2.45 secs, 598005744 bytes)
    *Interpreter> runR (createSum 2 1000000)
    2000000
    (25.77 secs, 5975805708 bytes)

    *Interpreter> runP (createSum 2 100)
    200
    (0.00 secs, 1581420 bytes)
    *Interpreter> runP (createSum 2 1000)
    2000
    (0.03 secs, 7294772 bytes)
    *Interpreter> runP (createSum 2 10000)
    20000
    (0.31 secs, 68390640 bytes)
    *Interpreter> runP (createSum 2 100000)
    200000
    (3.20 secs, 679890748 bytes)
    *Interpreter> runP (createSum 2 1000000)
    2000000
    (34.19 secs, 6795756656 bytes)

EVALUATING MULTIPLICATION:
    *Interpreter> runR (createMul 2 10000)  19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775629640762836880760732228535091641476183956381458969463899410840960536267821064621427333394036525565649530603142680234969400335934316651459297773279665775606172582031407994198179607378245683762280037302885487251900834464581454650557929601414833921615734588139257095379769119277800826957735674444123062018757836325502728323789270710373802866393031428133241401624195671690574061419654342324638801248856147305207431992259611796250130992860241708340807605932320161268492288496255841312844061536738951487114256315111089745514203313820202931640957596464756010405845841566072044962867016515061920631004186422275908670900574606417856951911456055068251250406007519842261898059237118054444788072906395242548339221982707404473162376760846613033778706039803413197133493654622700563169937455508241780972810983291314403571877524768509857276937926433221599399876886660808368837838027643282775172273657572744784112294389733810861607423253291974813120197604178281965697475898164531258434135959862784130128185406283476649088690521047580882615823961985770122407044330583075869039319604603404973156583208672105913300903752823415539745394397715257455290510212310947321610753474825740775273986348298498340756937955646638621874569499279016572103701364433135817214311791398222983845847334440270964182851005072927748364550578634501100852987812389473928699540834346158807043959118985815145779177143619698728131459483783202081474982171858011389071228250905826817436220577475921417653715687725614904582904992461028630081535583308130101987675856234343538955409175623400844887526162643568648833519463720377293240094456246923254350400678027273837755376406726898636241037491410966718557050759098100246789880178271925953381282421954028302759408448955014676668389697996886241636313376393903373455801407636741877711055384225739499110186468219696581651485130494222369947714763069155468217682876200362777257723781365331611196811280792669481887201298643660768551639860534602297871557517947385246369446923087894265948217008051120322365496288169035739121368338393591756418733850510970271613915439590991598154654417336311656936031122249937969999226781732358023111862644575299135758175008199839236284615249881088960232244362173771618086357015468484058622329792853875623486556440536962622018963571028812361567512543338303270029097668650568557157505516727518899194129711337690149916181315171544007728650573189557450920330185304847113818315407324053319038462084036421763703911550639789000742853672196280903477974533320468368795868580237952218629120080742819551317948157624448298518461509704888027274721574688131594750409732115080498190455803416826949787141316063210686391511681774304792596709376
    (0.27 secs, 66570724 bytes)

    *Interpreter> runP (createMul 2 10000)  19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775629640762836880760732228535091641476183956381458969463899410840960536267821064621427333394036525565649530603142680234969400335934316651459297773279665775606172582031407994198179607378245683762280037302885487251900834464581454650557929601414833921615734588139257095379769119277800826957735674444123062018757836325502728323789270710373802866393031428133241401624195671690574061419654342324638801248856147305207431992259611796250130992860241708340807605932320161268492288496255841312844061536738951487114256315111089745514203313820202931640957596464756010405845841566072044962867016515061920631004186422275908670900574606417856951911456055068251250406007519842261898059237118054444788072906395242548339221982707404473162376760846613033778706039803413197133493654622700563169937455508241780972810983291314403571877524768509857276937926433221599399876886660808368837838027643282775172273657572744784112294389733810861607423253291974813120197604178281965697475898164531258434135959862784130128185406283476649088690521047580882615823961985770122407044330583075869039319604603404973156583208672105913300903752823415539745394397715257455290510212310947321610753474825740775273986348298498340756937955646638621874569499279016572103701364433135817214311791398222983845847334440270964182851005072927748364550578634501100852987812389473928699540834346158807043959118985815145779177143619698728131459483783202081474982171858011389071228250905826817436220577475921417653715687725614904582904992461028630081535583308130101987675856234343538955409175623400844887526162643568648833519463720377293240094456246923254350400678027273837755376406726898636241037491410966718557050759098100246789880178271925953381282421954028302759408448955014676668389697996886241636313376393903373455801407636741877711055384225739499110186468219696581651485130494222369947714763069155468217682876200362777257723781365331611196811280792669481887201298643660768551639860534602297871557517947385246369446923087894265948217008051120322365496288169035739121368338393591756418733850510970271613915439590991598154654417336311656936031122249937969999226781732358023111862644575299135758175008199839236284615249881088960232244362173771618086357015468484058622329792853875623486556440536962622018963571028812361567512543338303270029097668650568557157505516727518899194129711337690149916181315171544007728650573189557450920330185304847113818315407324053319038462084036421763703911550639789000742853672196280903477974533320468368795868580237952218629120080742819551317948157624448298518461509704888027274721574688131594750409732115080498190455803416826949787141316063210686391511681774304792596709376
    (0.31 secs, 70660692 bytes)

DEALING WITH ORDER OF PRECENDENCE (ie: following the grammar correctly):
    *Interpreter> 5 + 2 * 10
    25
    (0.00 secs, 1037944 bytes)
    *Interpreter> runR "5 + 2 * 10"
    25
    (0.00 secs, 517932 bytes)
    *Interpreter> runP "5 + 2 * 10"
    25
    (0.02 secs, 519780 bytes)

    *Interpreter> (5 + 2) * 10
    70
    (0.00 secs, 517216 bytes)
    *Interpreter> runR "(5 + 2) * 10"
    70
    (0.00 secs, 518856 bytes)
    *Interpreter> runP "(5 + 2) * 10"
    70
    (0.00 secs, 520988 bytes)

BUILDING THE PARSE TREE:
    *Interpreter> parseR "(5 + 2) * 10"
    Op Mul [Op Add [Constant 5,Constant 2],Constant 10]
    (0.00 secs, 518296 bytes)
    *Interpreter> parseP "(5 + 2) * 10"
    Op Mul [Op Add [Constant 5,Constant 2],Constant 10]
    (0.00 secs, 518548 bytes)
    *Interpreter> parsePC "(5 + 2) * 10"
    C_Expr (C_Term (C_Expr (C_Term (C_Const 5) C_Epsilon) (C_Add (C_Term (C_Const 2) C_Epsilon) C_Epsilon)) (C_Mul (C_Const 10) C_Epsilon)) C_Epsilon
    (0.00 secs, 517696 bytes)
