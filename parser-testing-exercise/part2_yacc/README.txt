--Author: Yu-Yang Lin

The parser was generated by Happy using 'HappyParser.y' grammar file. 
The parser generated can be found in 'Main.hs'.
An info file named HappyParser.info contains detailed information about he GLR parser generated.
To use happy:

	happy HappyParser.y -o Main.hs 	-- it needs to be named Main.hs as its the defined module name.

You can test the parser by running Interpreter.hs or Main.hs on GHCI:
    
    ghci Interpreter.hs     -- parses and has an evaluation function "run" that handles runtime errors.
    ghci Main.hs            -- only has the parse and lexer functions, nothing else.

    :set +s -- to output time/space taken for a function

Main.hs is a parser, and can parse Strings by calling the function "parse", or by giving a String input
to its main. It can also tokenise using function "lexer".
eg:
    parse <String to parse>
    lexer <String to parse> -- I like how parse and lexer have the same word length, they line up.

Using GHCI should be enough, however -if desired- it is possible to compile Main.hs into a standalone
parser that doesn't use the Haskell interpreter:
    
    ghc Main.hs -o <output-name>

This should produce two additional files used by the parser. I have included the Windows binaries.
Once compiled, it will parse any argument given to its main.

I recommend using the Interpreter module I wrote to test the parser as it lets you evaluate.
The functions included in Interpreter are:
    
    eval :: Exp -> Either String Integer                            --evaluates an Exp tree.
    
    createSum, createMul, createBrackets :: Int -> Int -> String    --creates strings (as in part 1)
    
    createString :: String -> Int -> String                         --creates strings (as in part 1)
    
    run :: String -> IO()       --runs an String expression given to it.
                                --this function handles runtime errors (division by zero, etc)

    and all functions in Main.hs
	
NOTE: 	I have also included another parser, one that evaluates while parsing.
		The files can be found in:
			
			Eval_While_Parsing\
		
		Where you can find:
		
			Main.hs
			OnTheFly.y
		
		To test it, load Main.hs on GHCI and use the parse function:
		
			ghci Main.hs
			
			parse <String To Parse>	--this evaluates the String by evaluating as it parses.
			
		The COMMENTS section below contains information on how this can be extended.
			
======================================================================================================
------------------------------------------------------------------------------------------------------
======================================================================================================

COMMENTS:

    Testing data shows that the GLR parser generated by Happy is ~4x faster than my implementations
    in most cases. Considering its used to parse GHC its not suprising its better than my parsers.
    
    The grammar file I provided to Happy is extremely simple, and thus doesn't handle errors properly.
    If the parser fails, it will not be able to output why or where it failed, only what it failed on.
    
    To handle errors propperly, one can use Monadic Parsing, and Threaded Lexers. This can be done by
    requesting Monadic Support on the directive, and then adding the required Monadic Error Functions,
    defining Monadic Productions and designing a suitable Error data type for your error.
    
    Considering that involves a lot of coding and debugging of the parser and lexer, in addition to
    wrapping your head around what data is being bound by Monads, I decided against it.
    
    If implemented it, you can handle things like line number, position of the parser, etc.
    
    It should also be noted that defining a data structure that evaluates on the fly while parsing is
    possible in Haskell, and Happy allows this.
    
    eg.
    
    Given the following Production Rule:
        
        Exp   : let var '=' Exp in Exp  { Let $2 $4 $6 }
              | Exp1                    { Exp1 $1 }

        Exp1  : Exp1 '+' Term           { Plus $1 $3 }
              | Exp1 '-' Term           { Minus $1 $3 }
              | Term                    { Term $1 }
        
        Term  : Term '*' Factor         { Times $1 $3 }
              | Term '/' Factor         { Div $1 $3 }
              | Factor                  { Factor $1 }

        Factor            
              : int                     { Int $1 }
              | var                     { Var $1 }
              | '(' Exp ')'             { Brack $2 }
              
    One can instead define the following:
        
        Exp   : let var '=' Exp in Exp  { \p -> $6 (($2,$4 p):p) }
              | Exp1                    { $1 }

        Exp1  : Exp1 '+' Term           { \p -> $1 p + $3 p }
              | Exp1 '-' Term           { \p -> $1 p - $3 p }
              | Term                    { $1 }
              
        Term  : Term '*' Factor         { \p -> $1 p * $3 p }
              | Term '/' Factor         { \p -> $1 p `div` $3 p }
              | Factor                  { $1 }

        Factor            
              : int                     { \p -> $1 }
              | var                     { \p -> case lookup $1 p of
                                                Nothing -> error "no var"
                                                Just i  -> i }
              | '(' Exp ')'             { $2 }
              
    Production rules are functions that go from the Environment (p) to a value (v).
    This value will be in the environment when the parsing another construct.
    
    Thus, if "let" is being parsed, and the environment (p) holds the value (v), 
    the "var" function (again, productions are functions) will lookup the value (v)
    and send the result back up to the "let" production, assinging the value.
        
======================================================================================================
------------------------------------------------------------------------------------------------------
======================================================================================================

EXAMPLE TEST DATA:

NESTED BRACKETS:
    *Interpreter> run (createBrackets 5 1000000)
    5
    (4.94 secs, 1522914444 bytes)

ADDITION:
    *Interpreter> run (createSum 2 100)
    200
    (0.00 secs, 1071752 bytes)
    *Interpreter> run (createSum 2 1000)
    2000
    (0.00 secs, 5219736 bytes)
    *Interpreter> run (createSum 2 10000)
    20000
    (0.11 secs, 47312632 bytes)
    *Interpreter> run (createSum 2 100000)
    200000
    (1.02 secs, 466490424 bytes)
    *Interpreter> run (createSum 2 1000000)
    2000000
    (10.44 secs, 4659142532 bytes)
    
MULTIPLICATION:
    *Interpreter> run (createMul 2 10000)
    19950631168807583848837421626835850838234968318861924548520089498529438830221946
    63191996168403619459789933112942320912427155649134941378111759378593209632395785
    57300467937945267652465512660598955205500869181933115425086084606181046855090748
    66089624888090489894838009253941633257850621568309473902556912388065225096643874
    44104675987162698545322286853816169431577562964076283688076073222853509164147618
    39563814589694638994108409605362678210646214273333940365255656495306031426802349
    69400335934316651459297773279665775606172582031407994198179607378245683762280037
    30288548725190083446458145465055792960141483392161573458813925709537976911927780
    08269577356744441230620187578363255027283237892707103738028663930314281332414016
    24195671690574061419654342324638801248856147305207431992259611796250130992860241
    70834080760593232016126849228849625584131284406153673895148711425631511108974551
    42033138202029316409575964647560104058458415660720449628670165150619206310041864
    22275908670900574606417856951911456055068251250406007519842261898059237118054444
    78807290639524254833922198270740447316237676084661303377870603980341319713349365
    46227005631699374555082417809728109832913144035718775247685098572769379264332215
    99399876886660808368837838027643282775172273657572744784112294389733810861607423
    25329197481312019760417828196569747589816453125843413595986278413012818540628347
    66490886905210475808826158239619857701224070443305830758690393196046034049731565
    83208672105913300903752823415539745394397715257455290510212310947321610753474825
    74077527398634829849834075693795564663862187456949927901657210370136443313581721
    43117913982229838458473344402709641828510050729277483645505786345011008529878123
    89473928699540834346158807043959118985815145779177143619698728131459483783202081
    47498217185801138907122825090582681743622057747592141765371568772561490458290499
    24610286300815355833081301019876758562343435389554091756234008448875261626435686
    48833519463720377293240094456246923254350400678027273837755376406726898636241037
    49141096671855705075909810024678988017827192595338128242195402830275940844895501
    46766683896979968862416363133763939033734558014076367418777110553842257394991101
    86468219696581651485130494222369947714763069155468217682876200362777257723781365
    33161119681128079266948188720129864366076855163986053460229787155751794738524636
    94469230878942659482170080511203223654962881690357391213683383935917564187338505
    10970271613915439590991598154654417336311656936031122249937969999226781732358023
    11186264457529913575817500819983923628461524988108896023224436217377161808635701
    54684840586223297928538756234865564405369626220189635710288123615675125433383032
    70029097668650568557157505516727518899194129711337690149916181315171544007728650
    57318955745092033018530484711381831540732405331903846208403642176370391155063978
    90007428536721962809034779745333204683687958685802379522186291200807428195513179
    48157624448298518461509704888027274721574688131594750409732115080498190455803416
    826949787141316063210686391511681774304792596709376
    (0.09 secs, 54332448 bytes)
